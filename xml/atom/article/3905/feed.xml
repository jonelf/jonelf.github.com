<?xml version="1.0" encoding="UTF-8"?>
<feed xml:lang="en-US" xmlns="http://www.w3.org/2005/Atom">
  <title>Alice, Bob, and Mallory: Finding primes in parallel</title>
  <subtitle type="html">metasyntactics</subtitle>
  <id>tag:alicebobandmallory.com,2005:Typo</id>
  <generator uri="http://www.typosphere.org" version="4.0">Typo</generator>
  <link href="http://alicebobandmallory.com/xml/atom/article/3905/feed.xml" rel="self" type="application/atom+xml"/>
  <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel" rel="alternate" type="text/html"/>
  <updated>2011-01-21T10:58:29+01:00</updated>
  <entry>
    <author>
      <name>Jonas Elfstr√∂m</name>
    </author>
    <id>urn:uuid:2c932b6d-8c9c-4532-9b8f-85ea02fdd193</id>
    <published>2010-01-14T22:55:00+01:00</published>
    <updated>2011-01-21T10:58:29+01:00</updated>
    <title type="html">Finding primes in parallel</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel" rel="alternate" type="text/html"/>
    <category label="C#" term="c" scheme="http://alicebobandmallory.com/articles/category/c"/>
    <category label="Math" term="math" scheme="http://alicebobandmallory.com/articles/category/math"/>
    <summary type="html">&lt;p&gt;&lt;a href="http://www.codethinked.com/page/About-Me.aspx"&gt;Justin Etheredge&lt;/a&gt; has been blogging about his &lt;a href="http://www.codethinked.com/post/2010/01/08/TekPubs-Mastering-LINQ-Challenge.aspx"&gt;challenge&lt;/a&gt; to find prime numbers with LINQ. He &lt;a href="http://www.codethinked.com/post/2010/01/10/The-TekPub-LINQ-Challenge-Part-2-Faster-Algorithms.aspx"&gt;later&lt;/a&gt; used &lt;code&gt;AsParallel()&lt;/code&gt; (coming in .NET 4) to speed things up and then followed that up with &lt;a href="http://www.codethinked.com/post/2010/01/12/The-TekPub-LINQ-Challenge-And-The-Sieve-Of-Eratosthenes.aspx"&gt;a post&lt;/a&gt; about using &lt;a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"&gt;The Sieve Of Eratosthenes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As you can see in the comments of those posts I tried to speed the Sieve of Eratosthenes up by using &lt;code&gt;Parallel.For&lt;/code&gt; in the inner loop. I also tried AsParallel() in the LINQ expression but it made no difference in either case. At most it got 5% faster. I'm not sure but it could be that because SoE is very memory intense we could have a scaling issue and maybe also memory bandwidth exhaustion. This is mere speculation.&lt;/p&gt;

&lt;p&gt;I then searched for other algorithms and found &lt;a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin"&gt;The Sieve of Atkin&lt;/a&gt;. It uses less memory than SoE so I thought I'd give it a try.&lt;/p&gt;

&lt;p&gt;I set the limit to 20,000,000 and then benchmarked it. It timed in on 2.48s so actually worse than the 2.2s that SoE took. Not good!
Then I added &lt;code&gt;Parallel.For&lt;/code&gt; in the loop that did most of the work and  lo and behold, it scaled! I have two cores in my machine (T7200@2.0GHz) and the average runtime went down to 1.26s. That's almost linear and surprisingly good! If you happen have a quad core (or more) and feel like trying it out then please contact me. It would be interesting to see if it scales further. &lt;/p&gt;

&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;&lt;a href="#n1" name="n1"&gt;1&lt;/a&gt;
&lt;a href="#n2" name="n2"&gt;2&lt;/a&gt;
&lt;a href="#n3" name="n3"&gt;3&lt;/a&gt;
&lt;a href="#n4" name="n4"&gt;4&lt;/a&gt;
&lt;a href="#n5" name="n5"&gt;5&lt;/a&gt;
&lt;a href="#n6" name="n6"&gt;6&lt;/a&gt;
&lt;a href="#n7" name="n7"&gt;7&lt;/a&gt;
&lt;a href="#n8" name="n8"&gt;8&lt;/a&gt;
&lt;a href="#n9" name="n9"&gt;9&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n10" name="n10"&gt;10&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n11" name="n11"&gt;11&lt;/a&gt;
&lt;a href="#n12" name="n12"&gt;12&lt;/a&gt;
&lt;a href="#n13" name="n13"&gt;13&lt;/a&gt;
&lt;a href="#n14" name="n14"&gt;14&lt;/a&gt;
&lt;a href="#n15" name="n15"&gt;15&lt;/a&gt;
&lt;a href="#n16" name="n16"&gt;16&lt;/a&gt;
&lt;a href="#n17" name="n17"&gt;17&lt;/a&gt;
&lt;a href="#n18" name="n18"&gt;18&lt;/a&gt;
&lt;a href="#n19" name="n19"&gt;19&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n20" name="n20"&gt;20&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n21" name="n21"&gt;21&lt;/a&gt;
&lt;a href="#n22" name="n22"&gt;22&lt;/a&gt;
&lt;a href="#n23" name="n23"&gt;23&lt;/a&gt;
&lt;a href="#n24" name="n24"&gt;24&lt;/a&gt;
&lt;a href="#n25" name="n25"&gt;25&lt;/a&gt;
&lt;a href="#n26" name="n26"&gt;26&lt;/a&gt;
&lt;a href="#n27" name="n27"&gt;27&lt;/a&gt;
&lt;a href="#n28" name="n28"&gt;28&lt;/a&gt;
&lt;a href="#n29" name="n29"&gt;29&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n30" name="n30"&gt;30&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n31" name="n31"&gt;31&lt;/a&gt;
&lt;a href="#n32" name="n32"&gt;32&lt;/a&gt;
&lt;a href="#n33" name="n33"&gt;33&lt;/a&gt;
&lt;a href="#n34" name="n34"&gt;34&lt;/a&gt;
&lt;a href="#n35" name="n35"&gt;35&lt;/a&gt;
&lt;a href="#n36" name="n36"&gt;36&lt;/a&gt;
&lt;a href="#n37" name="n37"&gt;37&lt;/a&gt;
&lt;a href="#n38" name="n38"&gt;38&lt;/a&gt;
&lt;a href="#n39" name="n39"&gt;39&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n40" name="n40"&gt;40&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n41" name="n41"&gt;41&lt;/a&gt;
&lt;a href="#n42" name="n42"&gt;42&lt;/a&gt;
&lt;a href="#n43" name="n43"&gt;43&lt;/a&gt;
&lt;a href="#n44" name="n44"&gt;44&lt;/a&gt;
&lt;a href="#n45" name="n45"&gt;45&lt;/a&gt;
&lt;a href="#n46" name="n46"&gt;46&lt;/a&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; List&amp;lt;&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt;&amp;gt; FindPrimesBySieveOfAtkins(&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; max)
{
   &lt;span style="color:#777"&gt;//  var isPrime = new BitArray((int)max+1, false); &lt;/span&gt;
   &lt;span style="color:#777"&gt;//  Can't use BitArray because of threading issues.&lt;/span&gt;

    var isPrime = new &lt;span style="color:#0a5;font-weight:bold"&gt;bool&lt;/span&gt;[max + &lt;span style="color:#00D"&gt;1&lt;/span&gt;];
    var sqrt = (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt;)Math.Sqrt(max);

    Parallel.For(&lt;span style="color:#00D"&gt;1&lt;/span&gt;, sqrt, x =&amp;gt;
    {
        var xx = x * x;
        &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; y = &lt;span style="color:#00D"&gt;1&lt;/span&gt;; y &amp;lt;= sqrt; y++)
        {
            var yy = y * y;
            var n = &lt;span style="color:#00D"&gt;4&lt;/span&gt; * xx + yy;
            &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (n &amp;lt;= max &amp;amp;&amp;amp; (n % &lt;span style="color:#00D"&gt;12&lt;/span&gt; == &lt;span style="color:#00D"&gt;1&lt;/span&gt; || n % &lt;span style="color:#00D"&gt;12&lt;/span&gt; == &lt;span style="color:#00D"&gt;5&lt;/span&gt;))
                isPrime[n] ^= &lt;span style="color:#069"&gt;true&lt;/span&gt;;

            n = &lt;span style="color:#00D"&gt;3&lt;/span&gt; * xx + yy;
            &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (n &amp;lt;= max &amp;amp;&amp;amp; n % &lt;span style="color:#00D"&gt;12&lt;/span&gt; == &lt;span style="color:#00D"&gt;7&lt;/span&gt;)
                isPrime[n] ^= &lt;span style="color:#069"&gt;true&lt;/span&gt;;

            n = &lt;span style="color:#00D"&gt;3&lt;/span&gt; * xx - yy;
            &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (x &amp;gt; y &amp;amp;&amp;amp; n &amp;lt;= max &amp;amp;&amp;amp; n % &lt;span style="color:#00D"&gt;12&lt;/span&gt; == &lt;span style="color:#00D"&gt;11&lt;/span&gt;)
                isPrime[n] ^= &lt;span style="color:#069"&gt;true&lt;/span&gt;;
        }
    });

    var primes = new List&amp;lt;&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt;&amp;gt;() { &lt;span style="color:#00D"&gt;2&lt;/span&gt;, &lt;span style="color:#00D"&gt;3&lt;/span&gt; };
    &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; n = &lt;span style="color:#00D"&gt;5&lt;/span&gt;; n &amp;lt;= sqrt; n++)
    {
        &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (isPrime[n])
        {
            primes.Add(n);
            &lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; nn = n * n;
            &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; k = nn; k &amp;lt;= max; k += nn)
                isPrime[k] = &lt;span style="color:#069"&gt;false&lt;/span&gt;;
        }
    }

    &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; n = sqrt + &lt;span style="color:#00D"&gt;1&lt;/span&gt;; n &amp;lt;= max; n++)
        &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (isPrime[n])
            primes.Add(n);

    &lt;span style="color:#080;font-weight:bold"&gt;return&lt;/span&gt; primes;
}&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This code needs C# 4.0 to compile.
&lt;br&gt;&lt;br&gt;
&lt;font style="color:red;font-weight:bold"&gt;Edit 2010-12-14&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Dommer &lt;a href="http://stackoverflow.com/questions/1569127/c-implementation-of-the-sieve-of-atkin/2070579#2070579"&gt;found out&lt;/a&gt; that the BitArray implementation had some serious threading issues.
I had my worries about the non thread safe characteristics of BitArray but I thought that the isPrime[n] ^= true; was an atomic operation and that it didn't matter in what order bit bits was flipped would make it possible to use anyway. Not so. Changed it to a boolean array and that seems to rock the boat but of course at a much higher memory cost.
&lt;br&gt;&lt;br&gt;
&lt;font style="color:red;font-weight:bold"&gt;Edit 2010-01-20&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Indications are that this does in fact not scale very good on a quad core. It's even worse, it seems it scales good on my old T7200 but not on a dual core E6320. I don't know why but of course the shared state of the &lt;strong&gt;isPrime&lt;/strong&gt; &lt;code&gt;BitArray&lt;/code&gt; is a huge problem and maybe it could be that differences in CPU architecture (FSB speed, caches and so on) in the E6320 is an explanation. Average execution time on the E6320 was 1290ms in a single thread and 1064ms in two.&lt;/p&gt;

&lt;p&gt;If you want to try this in an older version of C# than 4.0 then check out &lt;a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html"&gt;this post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A reader asked how I timed the executions. Here's how.&lt;/p&gt;

&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;&lt;a href="#n1" name="n1"&gt;1&lt;/a&gt;
&lt;a href="#n2" name="n2"&gt;2&lt;/a&gt;
&lt;a href="#n3" name="n3"&gt;3&lt;/a&gt;
&lt;a href="#n4" name="n4"&gt;4&lt;/a&gt;
&lt;a href="#n5" name="n5"&gt;5&lt;/a&gt;
&lt;a href="#n6" name="n6"&gt;6&lt;/a&gt;
&lt;a href="#n7" name="n7"&gt;7&lt;/a&gt;
&lt;a href="#n8" name="n8"&gt;8&lt;/a&gt;
&lt;a href="#n9" name="n9"&gt;9&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n10" name="n10"&gt;10&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n11" name="n11"&gt;11&lt;/a&gt;
&lt;a href="#n12" name="n12"&gt;12&lt;/a&gt;
&lt;a href="#n13" name="n13"&gt;13&lt;/a&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;var steps = new List&amp;lt;&lt;span style="color:#0a5;font-weight:bold"&gt;long&lt;/span&gt;&amp;gt;();
var watch = new Stopwatch();

&lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; i = &lt;span style="color:#00D"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style="color:#00D"&gt;10&lt;/span&gt;; i++) 
{
    watch.Reset();
    watch.Start();
    var primes = FindPrimesBySieveOfAtkins(&lt;span style="color:#00D"&gt;20000000&lt;/span&gt;);
    watch.Stop();
    Console.WriteLine(watch.ElapsedMilliseconds.ToString());
    steps.Add(watch.ElapsedMilliseconds);
}
Console.WriteLine(&lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;Average: &lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; + steps.Average().ToString());&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;
&lt;font style="color:red;font-weight:bold"&gt;Edit 2010-10-24&lt;/font&gt;
&lt;br&gt;&lt;br&gt;
Tom's code from the comment below&lt;/p&gt;

&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;&lt;a href="#n1" name="n1"&gt;1&lt;/a&gt;
&lt;a href="#n2" name="n2"&gt;2&lt;/a&gt;
&lt;a href="#n3" name="n3"&gt;3&lt;/a&gt;
&lt;a href="#n4" name="n4"&gt;4&lt;/a&gt;
&lt;a href="#n5" name="n5"&gt;5&lt;/a&gt;
&lt;a href="#n6" name="n6"&gt;6&lt;/a&gt;
&lt;a href="#n7" name="n7"&gt;7&lt;/a&gt;
&lt;a href="#n8" name="n8"&gt;8&lt;/a&gt;
&lt;a href="#n9" name="n9"&gt;9&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n10" name="n10"&gt;10&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n11" name="n11"&gt;11&lt;/a&gt;
&lt;a href="#n12" name="n12"&gt;12&lt;/a&gt;
&lt;a href="#n13" name="n13"&gt;13&lt;/a&gt;
&lt;a href="#n14" name="n14"&gt;14&lt;/a&gt;
&lt;a href="#n15" name="n15"&gt;15&lt;/a&gt;
&lt;a href="#n16" name="n16"&gt;16&lt;/a&gt;
&lt;a href="#n17" name="n17"&gt;17&lt;/a&gt;
&lt;a href="#n18" name="n18"&gt;18&lt;/a&gt;
&lt;a href="#n19" name="n19"&gt;19&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n20" name="n20"&gt;20&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n21" name="n21"&gt;21&lt;/a&gt;
&lt;a href="#n22" name="n22"&gt;22&lt;/a&gt;
&lt;a href="#n23" name="n23"&gt;23&lt;/a&gt;
&lt;a href="#n24" name="n24"&gt;24&lt;/a&gt;
&lt;a href="#n25" name="n25"&gt;25&lt;/a&gt;
&lt;a href="#n26" name="n26"&gt;26&lt;/a&gt;
&lt;a href="#n27" name="n27"&gt;27&lt;/a&gt;
&lt;a href="#n28" name="n28"&gt;28&lt;/a&gt;
&lt;a href="#n29" name="n29"&gt;29&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n30" name="n30"&gt;30&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n31" name="n31"&gt;31&lt;/a&gt;
&lt;a href="#n32" name="n32"&gt;32&lt;/a&gt;
&lt;a href="#n33" name="n33"&gt;33&lt;/a&gt;
&lt;a href="#n34" name="n34"&gt;34&lt;/a&gt;
&lt;a href="#n35" name="n35"&gt;35&lt;/a&gt;
&lt;a href="#n36" name="n36"&gt;36&lt;/a&gt;
&lt;a href="#n37" name="n37"&gt;37&lt;/a&gt;
&lt;a href="#n38" name="n38"&gt;38&lt;/a&gt;
&lt;a href="#n39" name="n39"&gt;39&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n40" name="n40"&gt;40&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n41" name="n41"&gt;41&lt;/a&gt;
&lt;a href="#n42" name="n42"&gt;42&lt;/a&gt;
&lt;a href="#n43" name="n43"&gt;43&lt;/a&gt;
&lt;a href="#n44" name="n44"&gt;44&lt;/a&gt;
&lt;a href="#n45" name="n45"&gt;45&lt;/a&gt;
&lt;a href="#n46" name="n46"&gt;46&lt;/a&gt;
&lt;a href="#n47" name="n47"&gt;47&lt;/a&gt;
&lt;a href="#n48" name="n48"&gt;48&lt;/a&gt;
&lt;a href="#n49" name="n49"&gt;49&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n50" name="n50"&gt;50&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n51" name="n51"&gt;51&lt;/a&gt;
&lt;a href="#n52" name="n52"&gt;52&lt;/a&gt;
&lt;a href="#n53" name="n53"&gt;53&lt;/a&gt;
&lt;a href="#n54" name="n54"&gt;54&lt;/a&gt;
&lt;a href="#n55" name="n55"&gt;55&lt;/a&gt;
&lt;a href="#n56" name="n56"&gt;56&lt;/a&gt;
&lt;a href="#n57" name="n57"&gt;57&lt;/a&gt;
&lt;a href="#n58" name="n58"&gt;58&lt;/a&gt;
&lt;a href="#n59" name="n59"&gt;59&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n60" name="n60"&gt;60&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n61" name="n61"&gt;61&lt;/a&gt;
&lt;a href="#n62" name="n62"&gt;62&lt;/a&gt;
&lt;a href="#n63" name="n63"&gt;63&lt;/a&gt;
&lt;a href="#n64" name="n64"&gt;64&lt;/a&gt;
&lt;a href="#n65" name="n65"&gt;65&lt;/a&gt;
&lt;a href="#n66" name="n66"&gt;66&lt;/a&gt;
&lt;a href="#n67" name="n67"&gt;67&lt;/a&gt;
&lt;a href="#n68" name="n68"&gt;68&lt;/a&gt;
&lt;a href="#n69" name="n69"&gt;69&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n70" name="n70"&gt;70&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n71" name="n71"&gt;71&lt;/a&gt;
&lt;a href="#n72" name="n72"&gt;72&lt;/a&gt;
&lt;a href="#n73" name="n73"&gt;73&lt;/a&gt;
&lt;a href="#n74" name="n74"&gt;74&lt;/a&gt;
&lt;a href="#n75" name="n75"&gt;75&lt;/a&gt;
&lt;a href="#n76" name="n76"&gt;76&lt;/a&gt;
&lt;a href="#n77" name="n77"&gt;77&lt;/a&gt;
&lt;a href="#n78" name="n78"&gt;78&lt;/a&gt;
&lt;a href="#n79" name="n79"&gt;79&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n80" name="n80"&gt;80&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n81" name="n81"&gt;81&lt;/a&gt;
&lt;a href="#n82" name="n82"&gt;82&lt;/a&gt;
&lt;a href="#n83" name="n83"&gt;83&lt;/a&gt;
&lt;a href="#n84" name="n84"&gt;84&lt;/a&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Numerics; 
using System.Text; 
using System.Threading.Tasks;

namespace Calculate_Primes 
{ 
    class Program 
    { 
        private &lt;span style="color:#088;font-weight:bold"&gt;const&lt;/span&gt; &lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; _NUMBER_OF_DIGITS = &lt;span style="color:#00D"&gt;100&lt;/span&gt;;

        &lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#088;font-weight:bold"&gt;void&lt;/span&gt; Main(string[] args)
        {
            BigInteger floor = BigInteger.Parse(&lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;1&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; + string.Empty.PadLeft(_NUMBER_OF_DIGITS - &lt;span style="color:#00D"&gt;1&lt;/span&gt;, &lt;span style="color:#D20"&gt;'0'&lt;/span&gt;));
            BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, &lt;span style="color:#D20"&gt;'9'&lt;/span&gt;));

            Console.WindowWidth = &lt;span style="color:#00D"&gt;150&lt;/span&gt;;

            &lt;span style="color:#777"&gt;//var primes = Enumerable.Range(floor, ceiling).Where(n =&amp;gt; Enumerable.Range(1, n).Where(m =&amp;gt; (n / m) * m == n).Count() == 2);&lt;/span&gt;

            Console.Clear();
            _calculatePrimes(floor, ceiling, &lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;C:&lt;/span&gt;&lt;span style="color:#b0b"&gt;\\&lt;/span&gt;&lt;span style="color:#D20"&gt;100 digit primes.txt&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);

            Console.Clear();
            _calculatePrimes(floor, ceiling, &lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;C:&lt;/span&gt;&lt;span style="color:#b0b"&gt;\\&lt;/span&gt;&lt;span style="color:#D20"&gt;300 digit primes.txt&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
        }

        &lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; IEnumerable&amp;lt;BigInteger&amp;gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
        {
            &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (BigInteger i = fromInclusive; i &amp;lt;= toInclusive; i++)
                yield &lt;span style="color:#080;font-weight:bold"&gt;return&lt;/span&gt; i;
        }

        &lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#088;font-weight:bold"&gt;void&lt;/span&gt; ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&amp;lt;BigInteger&amp;gt; body)
        {
            Parallel.ForEach(Range(fromInclusive, toInclusive), body);
        } 

        &lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#088;font-weight:bold"&gt;void&lt;/span&gt; _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
        {
            using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

            using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
            {
                ParallelFor(floor, ceiling, i =&amp;gt;
                    {
                        &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (_isPrime(i))
                        {
                            lock (sw)
                            {
                                sw.Write(i.ToString() + System.Environment.NewLine);
                                sw.Flush();
                            }
                        }
                    });
            }
        }

        &lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#0a5;font-weight:bold"&gt;bool&lt;/span&gt; _isPrime(BigInteger number)
        {
            &lt;span style="color:#0a5;font-weight:bold"&gt;bool&lt;/span&gt; returnValue = &lt;span style="color:#069"&gt;true&lt;/span&gt;;

            Console.WriteLine(&lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;Checking {0} for primality.&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, number.ToString());

            &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; ((number &amp;lt; &lt;span style="color:#00D"&gt;2&lt;/span&gt;) || (number &amp;gt; &lt;span style="color:#00D"&gt;2&lt;/span&gt; &amp;amp;&amp;amp; number.IsEven) || (number &amp;gt; &lt;span style="color:#00D"&gt;2&lt;/span&gt; &amp;amp;&amp;amp; number.IsPowerOfTwo))
                returnValue = &lt;span style="color:#069"&gt;false&lt;/span&gt;;
            &lt;span style="color:#080;font-weight:bold"&gt;else&lt;/span&gt;
                &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (BigInteger i = &lt;span style="color:#00D"&gt;2&lt;/span&gt;; i * i &amp;lt;= number; i++)
                {
                    &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (number % i == &lt;span style="color:#00D"&gt;0&lt;/span&gt;)
                        returnValue = &lt;span style="color:#069"&gt;false&lt;/span&gt;;
                }

            &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt;(returnValue)
                Console.WriteLine(&lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;         {0} IS prime.&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, number.ToString());
            &lt;span style="color:#080;font-weight:bold"&gt;else&lt;/span&gt;
                Console.WriteLine(&lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;         {0} IS NOT prime.&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, number.ToString());

            &lt;span style="color:#080;font-weight:bold"&gt;return&lt;/span&gt; returnValue;
        }
    }
}&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;</summary>
    <content type="html">&lt;p&gt;&lt;a href="http://www.codethinked.com/page/About-Me.aspx"&gt;Justin Etheredge&lt;/a&gt; has been blogging about his &lt;a href="http://www.codethinked.com/post/2010/01/08/TekPubs-Mastering-LINQ-Challenge.aspx"&gt;challenge&lt;/a&gt; to find prime numbers with LINQ. He &lt;a href="http://www.codethinked.com/post/2010/01/10/The-TekPub-LINQ-Challenge-Part-2-Faster-Algorithms.aspx"&gt;later&lt;/a&gt; used &lt;code&gt;AsParallel()&lt;/code&gt; (coming in .NET 4) to speed things up and then followed that up with &lt;a href="http://www.codethinked.com/post/2010/01/12/The-TekPub-LINQ-Challenge-And-The-Sieve-Of-Eratosthenes.aspx"&gt;a post&lt;/a&gt; about using &lt;a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes"&gt;The Sieve Of Eratosthenes&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As you can see in the comments of those posts I tried to speed the Sieve of Eratosthenes up by using &lt;code&gt;Parallel.For&lt;/code&gt; in the inner loop. I also tried AsParallel() in the LINQ expression but it made no difference in either case. At most it got 5% faster. I'm not sure but it could be that because SoE is very memory intense we could have a scaling issue and maybe also memory bandwidth exhaustion. This is mere speculation.&lt;/p&gt;

&lt;p&gt;I then searched for other algorithms and found &lt;a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin"&gt;The Sieve of Atkin&lt;/a&gt;. It uses less memory than SoE so I thought I'd give it a try.&lt;/p&gt;

&lt;p&gt;I set the limit to 20,000,000 and then benchmarked it. It timed in on 2.48s so actually worse than the 2.2s that SoE took. Not good!
Then I added &lt;code&gt;Parallel.For&lt;/code&gt; in the loop that did most of the work and  lo and behold, it scaled! I have two cores in my machine (T7200@2.0GHz) and the average runtime went down to 1.26s. That's almost linear and surprisingly good! If you happen have a quad core (or more) and feel like trying it out then please contact me. It would be interesting to see if it scales further. &lt;/p&gt;

&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;&lt;a href="#n1" name="n1"&gt;1&lt;/a&gt;
&lt;a href="#n2" name="n2"&gt;2&lt;/a&gt;
&lt;a href="#n3" name="n3"&gt;3&lt;/a&gt;
&lt;a href="#n4" name="n4"&gt;4&lt;/a&gt;
&lt;a href="#n5" name="n5"&gt;5&lt;/a&gt;
&lt;a href="#n6" name="n6"&gt;6&lt;/a&gt;
&lt;a href="#n7" name="n7"&gt;7&lt;/a&gt;
&lt;a href="#n8" name="n8"&gt;8&lt;/a&gt;
&lt;a href="#n9" name="n9"&gt;9&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n10" name="n10"&gt;10&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n11" name="n11"&gt;11&lt;/a&gt;
&lt;a href="#n12" name="n12"&gt;12&lt;/a&gt;
&lt;a href="#n13" name="n13"&gt;13&lt;/a&gt;
&lt;a href="#n14" name="n14"&gt;14&lt;/a&gt;
&lt;a href="#n15" name="n15"&gt;15&lt;/a&gt;
&lt;a href="#n16" name="n16"&gt;16&lt;/a&gt;
&lt;a href="#n17" name="n17"&gt;17&lt;/a&gt;
&lt;a href="#n18" name="n18"&gt;18&lt;/a&gt;
&lt;a href="#n19" name="n19"&gt;19&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n20" name="n20"&gt;20&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n21" name="n21"&gt;21&lt;/a&gt;
&lt;a href="#n22" name="n22"&gt;22&lt;/a&gt;
&lt;a href="#n23" name="n23"&gt;23&lt;/a&gt;
&lt;a href="#n24" name="n24"&gt;24&lt;/a&gt;
&lt;a href="#n25" name="n25"&gt;25&lt;/a&gt;
&lt;a href="#n26" name="n26"&gt;26&lt;/a&gt;
&lt;a href="#n27" name="n27"&gt;27&lt;/a&gt;
&lt;a href="#n28" name="n28"&gt;28&lt;/a&gt;
&lt;a href="#n29" name="n29"&gt;29&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n30" name="n30"&gt;30&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n31" name="n31"&gt;31&lt;/a&gt;
&lt;a href="#n32" name="n32"&gt;32&lt;/a&gt;
&lt;a href="#n33" name="n33"&gt;33&lt;/a&gt;
&lt;a href="#n34" name="n34"&gt;34&lt;/a&gt;
&lt;a href="#n35" name="n35"&gt;35&lt;/a&gt;
&lt;a href="#n36" name="n36"&gt;36&lt;/a&gt;
&lt;a href="#n37" name="n37"&gt;37&lt;/a&gt;
&lt;a href="#n38" name="n38"&gt;38&lt;/a&gt;
&lt;a href="#n39" name="n39"&gt;39&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n40" name="n40"&gt;40&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n41" name="n41"&gt;41&lt;/a&gt;
&lt;a href="#n42" name="n42"&gt;42&lt;/a&gt;
&lt;a href="#n43" name="n43"&gt;43&lt;/a&gt;
&lt;a href="#n44" name="n44"&gt;44&lt;/a&gt;
&lt;a href="#n45" name="n45"&gt;45&lt;/a&gt;
&lt;a href="#n46" name="n46"&gt;46&lt;/a&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;&lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; List&amp;lt;&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt;&amp;gt; FindPrimesBySieveOfAtkins(&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; max)
{
   &lt;span style="color:#777"&gt;//  var isPrime = new BitArray((int)max+1, false); &lt;/span&gt;
   &lt;span style="color:#777"&gt;//  Can't use BitArray because of threading issues.&lt;/span&gt;

    var isPrime = new &lt;span style="color:#0a5;font-weight:bold"&gt;bool&lt;/span&gt;[max + &lt;span style="color:#00D"&gt;1&lt;/span&gt;];
    var sqrt = (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt;)Math.Sqrt(max);

    Parallel.For(&lt;span style="color:#00D"&gt;1&lt;/span&gt;, sqrt, x =&amp;gt;
    {
        var xx = x * x;
        &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; y = &lt;span style="color:#00D"&gt;1&lt;/span&gt;; y &amp;lt;= sqrt; y++)
        {
            var yy = y * y;
            var n = &lt;span style="color:#00D"&gt;4&lt;/span&gt; * xx + yy;
            &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (n &amp;lt;= max &amp;amp;&amp;amp; (n % &lt;span style="color:#00D"&gt;12&lt;/span&gt; == &lt;span style="color:#00D"&gt;1&lt;/span&gt; || n % &lt;span style="color:#00D"&gt;12&lt;/span&gt; == &lt;span style="color:#00D"&gt;5&lt;/span&gt;))
                isPrime[n] ^= &lt;span style="color:#069"&gt;true&lt;/span&gt;;

            n = &lt;span style="color:#00D"&gt;3&lt;/span&gt; * xx + yy;
            &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (n &amp;lt;= max &amp;amp;&amp;amp; n % &lt;span style="color:#00D"&gt;12&lt;/span&gt; == &lt;span style="color:#00D"&gt;7&lt;/span&gt;)
                isPrime[n] ^= &lt;span style="color:#069"&gt;true&lt;/span&gt;;

            n = &lt;span style="color:#00D"&gt;3&lt;/span&gt; * xx - yy;
            &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (x &amp;gt; y &amp;amp;&amp;amp; n &amp;lt;= max &amp;amp;&amp;amp; n % &lt;span style="color:#00D"&gt;12&lt;/span&gt; == &lt;span style="color:#00D"&gt;11&lt;/span&gt;)
                isPrime[n] ^= &lt;span style="color:#069"&gt;true&lt;/span&gt;;
        }
    });

    var primes = new List&amp;lt;&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt;&amp;gt;() { &lt;span style="color:#00D"&gt;2&lt;/span&gt;, &lt;span style="color:#00D"&gt;3&lt;/span&gt; };
    &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; n = &lt;span style="color:#00D"&gt;5&lt;/span&gt;; n &amp;lt;= sqrt; n++)
    {
        &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (isPrime[n])
        {
            primes.Add(n);
            &lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; nn = n * n;
            &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; k = nn; k &amp;lt;= max; k += nn)
                isPrime[k] = &lt;span style="color:#069"&gt;false&lt;/span&gt;;
        }
    }

    &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; n = sqrt + &lt;span style="color:#00D"&gt;1&lt;/span&gt;; n &amp;lt;= max; n++)
        &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (isPrime[n])
            primes.Add(n);

    &lt;span style="color:#080;font-weight:bold"&gt;return&lt;/span&gt; primes;
}&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;This code needs C# 4.0 to compile.
&lt;br&gt;&lt;br&gt;
&lt;font style="color:red;font-weight:bold"&gt;Edit 2010-12-14&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Dommer &lt;a href="http://stackoverflow.com/questions/1569127/c-implementation-of-the-sieve-of-atkin/2070579#2070579"&gt;found out&lt;/a&gt; that the BitArray implementation had some serious threading issues.
I had my worries about the non thread safe characteristics of BitArray but I thought that the isPrime[n] ^= true; was an atomic operation and that it didn't matter in what order bit bits was flipped would make it possible to use anyway. Not so. Changed it to a boolean array and that seems to rock the boat but of course at a much higher memory cost.
&lt;br&gt;&lt;br&gt;
&lt;font style="color:red;font-weight:bold"&gt;Edit 2010-01-20&lt;/font&gt;&lt;/p&gt;

&lt;p&gt;Indications are that this does in fact not scale very good on a quad core. It's even worse, it seems it scales good on my old T7200 but not on a dual core E6320. I don't know why but of course the shared state of the &lt;strong&gt;isPrime&lt;/strong&gt; &lt;code&gt;BitArray&lt;/code&gt; is a huge problem and maybe it could be that differences in CPU architecture (FSB speed, caches and so on) in the E6320 is an explanation. Average execution time on the E6320 was 1290ms in a single thread and 1064ms in two.&lt;/p&gt;

&lt;p&gt;If you want to try this in an older version of C# than 4.0 then check out &lt;a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html"&gt;this post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A reader asked how I timed the executions. Here's how.&lt;/p&gt;

&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;&lt;a href="#n1" name="n1"&gt;1&lt;/a&gt;
&lt;a href="#n2" name="n2"&gt;2&lt;/a&gt;
&lt;a href="#n3" name="n3"&gt;3&lt;/a&gt;
&lt;a href="#n4" name="n4"&gt;4&lt;/a&gt;
&lt;a href="#n5" name="n5"&gt;5&lt;/a&gt;
&lt;a href="#n6" name="n6"&gt;6&lt;/a&gt;
&lt;a href="#n7" name="n7"&gt;7&lt;/a&gt;
&lt;a href="#n8" name="n8"&gt;8&lt;/a&gt;
&lt;a href="#n9" name="n9"&gt;9&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n10" name="n10"&gt;10&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n11" name="n11"&gt;11&lt;/a&gt;
&lt;a href="#n12" name="n12"&gt;12&lt;/a&gt;
&lt;a href="#n13" name="n13"&gt;13&lt;/a&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;var steps = new List&amp;lt;&lt;span style="color:#0a5;font-weight:bold"&gt;long&lt;/span&gt;&amp;gt;();
var watch = new Stopwatch();

&lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (&lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; i = &lt;span style="color:#00D"&gt;0&lt;/span&gt;; i &amp;lt; &lt;span style="color:#00D"&gt;10&lt;/span&gt;; i++) 
{
    watch.Reset();
    watch.Start();
    var primes = FindPrimesBySieveOfAtkins(&lt;span style="color:#00D"&gt;20000000&lt;/span&gt;);
    watch.Stop();
    Console.WriteLine(watch.ElapsedMilliseconds.ToString());
    steps.Add(watch.ElapsedMilliseconds);
}
Console.WriteLine(&lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;Average: &lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; + steps.Average().ToString());&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;&lt;br&gt;&lt;br&gt;
&lt;font style="color:red;font-weight:bold"&gt;Edit 2010-10-24&lt;/font&gt;
&lt;br&gt;&lt;br&gt;
Tom's code from the comment below&lt;/p&gt;

&lt;table class="CodeRay"&gt;&lt;tr&gt;
  &lt;td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"&gt;&lt;pre&gt;&lt;a href="#n1" name="n1"&gt;1&lt;/a&gt;
&lt;a href="#n2" name="n2"&gt;2&lt;/a&gt;
&lt;a href="#n3" name="n3"&gt;3&lt;/a&gt;
&lt;a href="#n4" name="n4"&gt;4&lt;/a&gt;
&lt;a href="#n5" name="n5"&gt;5&lt;/a&gt;
&lt;a href="#n6" name="n6"&gt;6&lt;/a&gt;
&lt;a href="#n7" name="n7"&gt;7&lt;/a&gt;
&lt;a href="#n8" name="n8"&gt;8&lt;/a&gt;
&lt;a href="#n9" name="n9"&gt;9&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n10" name="n10"&gt;10&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n11" name="n11"&gt;11&lt;/a&gt;
&lt;a href="#n12" name="n12"&gt;12&lt;/a&gt;
&lt;a href="#n13" name="n13"&gt;13&lt;/a&gt;
&lt;a href="#n14" name="n14"&gt;14&lt;/a&gt;
&lt;a href="#n15" name="n15"&gt;15&lt;/a&gt;
&lt;a href="#n16" name="n16"&gt;16&lt;/a&gt;
&lt;a href="#n17" name="n17"&gt;17&lt;/a&gt;
&lt;a href="#n18" name="n18"&gt;18&lt;/a&gt;
&lt;a href="#n19" name="n19"&gt;19&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n20" name="n20"&gt;20&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n21" name="n21"&gt;21&lt;/a&gt;
&lt;a href="#n22" name="n22"&gt;22&lt;/a&gt;
&lt;a href="#n23" name="n23"&gt;23&lt;/a&gt;
&lt;a href="#n24" name="n24"&gt;24&lt;/a&gt;
&lt;a href="#n25" name="n25"&gt;25&lt;/a&gt;
&lt;a href="#n26" name="n26"&gt;26&lt;/a&gt;
&lt;a href="#n27" name="n27"&gt;27&lt;/a&gt;
&lt;a href="#n28" name="n28"&gt;28&lt;/a&gt;
&lt;a href="#n29" name="n29"&gt;29&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n30" name="n30"&gt;30&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n31" name="n31"&gt;31&lt;/a&gt;
&lt;a href="#n32" name="n32"&gt;32&lt;/a&gt;
&lt;a href="#n33" name="n33"&gt;33&lt;/a&gt;
&lt;a href="#n34" name="n34"&gt;34&lt;/a&gt;
&lt;a href="#n35" name="n35"&gt;35&lt;/a&gt;
&lt;a href="#n36" name="n36"&gt;36&lt;/a&gt;
&lt;a href="#n37" name="n37"&gt;37&lt;/a&gt;
&lt;a href="#n38" name="n38"&gt;38&lt;/a&gt;
&lt;a href="#n39" name="n39"&gt;39&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n40" name="n40"&gt;40&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n41" name="n41"&gt;41&lt;/a&gt;
&lt;a href="#n42" name="n42"&gt;42&lt;/a&gt;
&lt;a href="#n43" name="n43"&gt;43&lt;/a&gt;
&lt;a href="#n44" name="n44"&gt;44&lt;/a&gt;
&lt;a href="#n45" name="n45"&gt;45&lt;/a&gt;
&lt;a href="#n46" name="n46"&gt;46&lt;/a&gt;
&lt;a href="#n47" name="n47"&gt;47&lt;/a&gt;
&lt;a href="#n48" name="n48"&gt;48&lt;/a&gt;
&lt;a href="#n49" name="n49"&gt;49&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n50" name="n50"&gt;50&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n51" name="n51"&gt;51&lt;/a&gt;
&lt;a href="#n52" name="n52"&gt;52&lt;/a&gt;
&lt;a href="#n53" name="n53"&gt;53&lt;/a&gt;
&lt;a href="#n54" name="n54"&gt;54&lt;/a&gt;
&lt;a href="#n55" name="n55"&gt;55&lt;/a&gt;
&lt;a href="#n56" name="n56"&gt;56&lt;/a&gt;
&lt;a href="#n57" name="n57"&gt;57&lt;/a&gt;
&lt;a href="#n58" name="n58"&gt;58&lt;/a&gt;
&lt;a href="#n59" name="n59"&gt;59&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n60" name="n60"&gt;60&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n61" name="n61"&gt;61&lt;/a&gt;
&lt;a href="#n62" name="n62"&gt;62&lt;/a&gt;
&lt;a href="#n63" name="n63"&gt;63&lt;/a&gt;
&lt;a href="#n64" name="n64"&gt;64&lt;/a&gt;
&lt;a href="#n65" name="n65"&gt;65&lt;/a&gt;
&lt;a href="#n66" name="n66"&gt;66&lt;/a&gt;
&lt;a href="#n67" name="n67"&gt;67&lt;/a&gt;
&lt;a href="#n68" name="n68"&gt;68&lt;/a&gt;
&lt;a href="#n69" name="n69"&gt;69&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n70" name="n70"&gt;70&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n71" name="n71"&gt;71&lt;/a&gt;
&lt;a href="#n72" name="n72"&gt;72&lt;/a&gt;
&lt;a href="#n73" name="n73"&gt;73&lt;/a&gt;
&lt;a href="#n74" name="n74"&gt;74&lt;/a&gt;
&lt;a href="#n75" name="n75"&gt;75&lt;/a&gt;
&lt;a href="#n76" name="n76"&gt;76&lt;/a&gt;
&lt;a href="#n77" name="n77"&gt;77&lt;/a&gt;
&lt;a href="#n78" name="n78"&gt;78&lt;/a&gt;
&lt;a href="#n79" name="n79"&gt;79&lt;/a&gt;
&lt;strong&gt;&lt;a href="#n80" name="n80"&gt;80&lt;/a&gt;&lt;/strong&gt;
&lt;a href="#n81" name="n81"&gt;81&lt;/a&gt;
&lt;a href="#n82" name="n82"&gt;82&lt;/a&gt;
&lt;a href="#n83" name="n83"&gt;83&lt;/a&gt;
&lt;a href="#n84" name="n84"&gt;84&lt;/a&gt;
&lt;/pre&gt;&lt;/td&gt;
  &lt;td class="code"&gt;&lt;pre&gt;using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Numerics; 
using System.Text; 
using System.Threading.Tasks;

namespace Calculate_Primes 
{ 
    class Program 
    { 
        private &lt;span style="color:#088;font-weight:bold"&gt;const&lt;/span&gt; &lt;span style="color:#0a5;font-weight:bold"&gt;int&lt;/span&gt; _NUMBER_OF_DIGITS = &lt;span style="color:#00D"&gt;100&lt;/span&gt;;

        &lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#088;font-weight:bold"&gt;void&lt;/span&gt; Main(string[] args)
        {
            BigInteger floor = BigInteger.Parse(&lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;1&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; + string.Empty.PadLeft(_NUMBER_OF_DIGITS - &lt;span style="color:#00D"&gt;1&lt;/span&gt;, &lt;span style="color:#D20"&gt;'0'&lt;/span&gt;));
            BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, &lt;span style="color:#D20"&gt;'9'&lt;/span&gt;));

            Console.WindowWidth = &lt;span style="color:#00D"&gt;150&lt;/span&gt;;

            &lt;span style="color:#777"&gt;//var primes = Enumerable.Range(floor, ceiling).Where(n =&amp;gt; Enumerable.Range(1, n).Where(m =&amp;gt; (n / m) * m == n).Count() == 2);&lt;/span&gt;

            Console.Clear();
            _calculatePrimes(floor, ceiling, &lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;C:&lt;/span&gt;&lt;span style="color:#b0b"&gt;\\&lt;/span&gt;&lt;span style="color:#D20"&gt;100 digit primes.txt&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);

            Console.Clear();
            _calculatePrimes(floor, ceiling, &lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;C:&lt;/span&gt;&lt;span style="color:#b0b"&gt;\\&lt;/span&gt;&lt;span style="color:#D20"&gt;300 digit primes.txt&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
        }

        &lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; IEnumerable&amp;lt;BigInteger&amp;gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
        {
            &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (BigInteger i = fromInclusive; i &amp;lt;= toInclusive; i++)
                yield &lt;span style="color:#080;font-weight:bold"&gt;return&lt;/span&gt; i;
        }

        &lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#088;font-weight:bold"&gt;void&lt;/span&gt; ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&amp;lt;BigInteger&amp;gt; body)
        {
            Parallel.ForEach(Range(fromInclusive, toInclusive), body);
        } 

        &lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#088;font-weight:bold"&gt;void&lt;/span&gt; _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
        {
            using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

            using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
            {
                ParallelFor(floor, ceiling, i =&amp;gt;
                    {
                        &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (_isPrime(i))
                        {
                            lock (sw)
                            {
                                sw.Write(i.ToString() + System.Environment.NewLine);
                                sw.Flush();
                            }
                        }
                    });
            }
        }

        &lt;span style="color:#088;font-weight:bold"&gt;static&lt;/span&gt; &lt;span style="color:#0a5;font-weight:bold"&gt;bool&lt;/span&gt; _isPrime(BigInteger number)
        {
            &lt;span style="color:#0a5;font-weight:bold"&gt;bool&lt;/span&gt; returnValue = &lt;span style="color:#069"&gt;true&lt;/span&gt;;

            Console.WriteLine(&lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;Checking {0} for primality.&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, number.ToString());

            &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; ((number &amp;lt; &lt;span style="color:#00D"&gt;2&lt;/span&gt;) || (number &amp;gt; &lt;span style="color:#00D"&gt;2&lt;/span&gt; &amp;amp;&amp;amp; number.IsEven) || (number &amp;gt; &lt;span style="color:#00D"&gt;2&lt;/span&gt; &amp;amp;&amp;amp; number.IsPowerOfTwo))
                returnValue = &lt;span style="color:#069"&gt;false&lt;/span&gt;;
            &lt;span style="color:#080;font-weight:bold"&gt;else&lt;/span&gt;
                &lt;span style="color:#080;font-weight:bold"&gt;for&lt;/span&gt; (BigInteger i = &lt;span style="color:#00D"&gt;2&lt;/span&gt;; i * i &amp;lt;= number; i++)
                {
                    &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt; (number % i == &lt;span style="color:#00D"&gt;0&lt;/span&gt;)
                        returnValue = &lt;span style="color:#069"&gt;false&lt;/span&gt;;
                }

            &lt;span style="color:#080;font-weight:bold"&gt;if&lt;/span&gt;(returnValue)
                Console.WriteLine(&lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;         {0} IS prime.&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, number.ToString());
            &lt;span style="color:#080;font-weight:bold"&gt;else&lt;/span&gt;
                Console.WriteLine(&lt;span style="background-color:hsla(0,100%,50%,0.05)"&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;span style="color:#D20"&gt;         {0} IS NOT prime.&lt;/span&gt;&lt;span style="color:#710"&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, number.ToString());

            &lt;span style="color:#080;font-weight:bold"&gt;return&lt;/span&gt; returnValue;
        }
    }
}&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Jonas</name>
    </author>
    <id>urn:uuid:61d2f951-e3d5-45b1-b7c5-b67295bee2ea</id>
    <published>2012-03-14T01:20:19+01:00</published>
    <updated>2012-03-16T00:31:40+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Jonas</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-7589" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&amp;#8217;t it be affected by all other threads?&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Aaron M</name>
    </author>
    <id>urn:uuid:033c3b05-e2de-4aec-ba33-bb3d1c99d659</id>
    <published>2012-03-10T21:18:45+01:00</published>
    <updated>2012-03-14T01:16:51+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Aaron M</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-7547" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Freeman</name>
    </author>
    <id>urn:uuid:7984b2f2-7f37-48bd-8f99-9835699708f4</id>
    <published>2011-11-16T15:00:58+01:00</published>
    <updated>2011-11-17T22:12:02+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Freeman</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-6723" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Dave Jellison</name>
    </author>
    <id>urn:uuid:5c2b7d89-0c01-403e-b352-0e68129a53d6</id>
    <published>2011-02-17T01:01:58+01:00</published>
    <updated>2011-02-18T15:56:00+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Dave Jellison</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-5234" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Jonas Elfstr√∂m</name>
    </author>
    <id>urn:uuid:3cc82064-caa2-406a-b302-42873a922a2a</id>
    <published>2010-12-22T11:20:23+01:00</published>
    <updated>2010-12-22T11:20:46+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Jonas Elfstr√∂m</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-5199" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&amp;#8217;m not surprised because I just did a naive translation from the &lt;a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin"&gt;pseudo code on Wikipedia&lt;/a&gt; to C#.&lt;/p&gt;

&lt;p&gt;Also my implementation can&amp;#8217;t handle searching for primes up to 1000000000. It seems to be the line &lt;code&gt;int n = 4 * xx + yy;&lt;/code&gt; that is the problem. &lt;code&gt;4*xx+yy&lt;/code&gt; does not fit in a &lt;code&gt;Int32&lt;/code&gt; for max=1000000000.&lt;/p&gt;

&lt;pre&gt;
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
&lt;/pre&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Peter</name>
    </author>
    <id>urn:uuid:bce812a5-ca78-4cf3-bcce-8ba5f69b368c</id>
    <published>2010-12-21T16:47:04+01:00</published>
    <updated>2010-12-22T11:20:45+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Peter</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-5197" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6&lt;/p&gt;

&lt;p&gt;Regards,&lt;/p&gt;

&lt;p&gt;Peter&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Jonas Elfstr√∂m</name>
    </author>
    <id>urn:uuid:bb003385-e126-4cae-a3f4-17a3923176c1</id>
    <published>2010-10-24T00:22:29+02:00</published>
    <updated>2010-10-24T00:23:06+02:00</updated>
    <title type="html">Comment on Finding primes in parallel by Jonas Elfstr√∂m</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-4403" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. &lt;/p&gt;

&lt;p&gt;I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&amp;#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&amp;#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Jonas Elfstr√∂m</name>
    </author>
    <id>urn:uuid:d496a377-531b-4650-a55f-1d95e25d42f4</id>
    <published>2010-10-24T00:10:50+02:00</published>
    <updated>2010-10-24T00:23:05+02:00</updated>
    <title type="html">Comment on Finding primes in parallel by Jonas Elfstr√∂m</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-4402" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;@Tom&lt;/p&gt;

&lt;blockquote&gt;
    &lt;p&gt;isPrime[n] ^= true&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;An XOR toggle, nice! I haven&amp;#8217;t checked it but I would guess that both that and mine compile to something similar.&lt;/p&gt;

&lt;blockquote&gt;
    &lt;p&gt;No more atomicity.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now you lost me. I believe it is and that that&amp;#8217;s a good thing.&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Tom</name>
    </author>
    <id>urn:uuid:de8575e4-bc06-4c84-9b30-f73c01e40bed</id>
    <published>2010-10-22T18:59:47+02:00</published>
    <updated>2010-10-23T23:58:42+02:00</updated>
    <title type="html">Comment on Finding primes in parallel by Tom</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-4398" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;Here&amp;#8217;s a little something I came up with&amp;#8211;except for the commented out LINQ query&amp;#8211;using Stephen Toub&amp;#8217;s comments on Scott Hansellman&amp;#8217;s blog:&lt;/p&gt;

&lt;p&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int &lt;em&gt;NUMBER&lt;/em&gt;OF_DIGITS = 100;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&amp;gt; Enumerable.Range(1, n).Where(m =&amp;gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&amp;lt;BigInteger&amp;gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &amp;lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&amp;lt;BigInteger&amp;gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&amp;gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &amp;lt; 2) || (number &amp;gt; 2 &amp;amp;&amp;amp; number.IsEven) || (number &amp;gt; 2 &amp;amp;&amp;amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &amp;lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Tom</name>
    </author>
    <id>urn:uuid:79543d2a-2508-4f02-a0fc-50762ef126a8</id>
    <published>2010-10-22T18:35:54+02:00</published>
    <updated>2010-10-23T23:58:41+02:00</updated>
    <title type="html">Comment on Finding primes in parallel by Tom</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-4397" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;These lines:
isPrime[n] = !isPrime[n];&lt;/p&gt;

&lt;p&gt;Should be replaced with
isPrime[n] ^= true;&lt;/p&gt;

&lt;p&gt;No more atomicity.&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Jonas Elfstr√∂m</name>
    </author>
    <id>urn:uuid:d5f02f7b-3ad8-44c6-b427-17d58eec4f51</id>
    <published>2010-01-20T09:11:22+01:00</published>
    <updated>2010-03-15T10:49:57+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Jonas Elfstr√∂m</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-3939" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;&lt;a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html"&gt;http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html&lt;/a&gt; - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Svish</name>
    </author>
    <id>urn:uuid:ab5f14c5-6d7f-4149-84cb-383057d2e248</id>
    <published>2010-01-19T18:33:16+01:00</published>
    <updated>2010-03-15T10:50:00+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Svish</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-3934" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;So should maybe use the Set method instead then? Or doesn&amp;#8217;t make much difference perhaps&amp;#8230;&lt;/p&gt;

&lt;p&gt;Thanks for the link. Will check it out :)&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Jonas Elfstr√∂m</name>
    </author>
    <id>urn:uuid:cc5562be-58a8-4d77-b9f1-bc2ff135ce61</id>
    <published>2010-01-16T16:11:21+01:00</published>
    <updated>2010-03-15T10:49:58+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Jonas Elfstr√∂m</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-3919" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;&lt;i&gt;&amp;#8220;I was wondering if it could be done in a nice way without using Parallel.&amp;#8221;&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;Check out:  &lt;a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx"&gt;http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx&lt;/a&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Jonas Elfstr√∂m</name>
    </author>
    <id>urn:uuid:5c6e0ff7-7806-4f22-9995-72d7d9531954</id>
    <published>2010-01-15T17:24:41+01:00</published>
    <updated>2010-01-16T16:13:00+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Jonas Elfstr√∂m</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-3914" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;If Holterman is correct then my usage is thread safe: &lt;a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686"&gt;http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686&lt;/a&gt;&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Jonas Elfstr√∂m</name>
    </author>
    <id>urn:uuid:254adce2-07ea-4bbf-adec-abf09c5dbf4c</id>
    <published>2010-01-15T16:23:15+01:00</published>
    <updated>2010-01-16T16:13:04+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Jonas Elfstr√∂m</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-3913" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;That&amp;#8217;s for &amp;#8220;long, ulong, double, and decimal&amp;#8221;.
Read/write of booleans is atomic. I&amp;#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Svish</name>
    </author>
    <id>urn:uuid:0fbcedf0-41f7-48b3-a761-e72922250f46</id>
    <published>2010-01-15T15:50:13+01:00</published>
    <updated>2010-01-16T16:13:04+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Svish</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-3912" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;From that link you posted: &amp;#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&amp;#8221; &amp;#8211; Wouldn&amp;#8217;t that mean that it is not thread-safe? or?&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Svish</name>
    </author>
    <id>urn:uuid:e3c5ceb0-c341-430d-be76-77eccded5be8</id>
    <published>2010-01-15T15:47:57+01:00</published>
    <updated>2010-01-16T16:13:03+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Svish</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-3911" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Jonas Elfstr√∂m</name>
    </author>
    <id>urn:uuid:83d5ec5d-e28b-4bde-9d11-5c211ea3d7fb</id>
    <published>2010-01-15T13:33:16+01:00</published>
    <updated>2010-01-16T16:13:02+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Jonas Elfstr√∂m</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-3909" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;Replace the Parallel.For with
for (int x = 1; x &amp;lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.&lt;/p&gt;

&lt;p&gt;If I understand 
&lt;a href="http://bit.ly/8lZagW"&gt;http://bit.ly/8lZagW&lt;/a&gt; correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!&lt;/p&gt;</content>
  </entry>
  <entry>
    <author>
      <name>Svish</name>
    </author>
    <id>urn:uuid:16e6e69c-cc7a-47ee-92b3-8a2a7904f05f</id>
    <published>2010-01-15T11:03:18+01:00</published>
    <updated>2010-01-16T16:13:00+01:00</updated>
    <title type="html">Comment on Finding primes in parallel by Svish</title>
    <link href="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel#comment-3908" rel="alternate" type="text/html"/>
    <content type="html">&lt;p&gt;Are BitArrays thread-safe, or how does that work?&lt;/p&gt;

&lt;p&gt;Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p&lt;/p&gt;</content>
  </entry>
</feed>
