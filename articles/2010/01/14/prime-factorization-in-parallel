<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>Finding primes in parallel</title>
  <meta name="viewport" content="width=device-width; initial-scale=1.0;">
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  
  <link rel="EditURI" type="application/rsd+xml" title="RSD" href="../../../../xml/rsd" />
  <link rel="alternate" type="application/atom+xml" title="Atom" href="../../../../xml/atom/article/3905/feed.xml" />
  <link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../xml/rss20/article/3905/feed.xml" />
  <script src="../../../../javascripts/cookies.js?1170454372" type="text/javascript"></script>
  <script src="../../../../javascripts/prototype.js?1170454372" type="text/javascript"></script>
  <script src="../../../../javascripts/effects.js?1170454372" type="text/javascript"></script>
  <script src="../../../../javascripts/typo.js?1170454372" type="text/javascript"></script>
  
  <script type="text/javascript"></script>
  <link href="../../../../stylesheets/theme/application.css?1357773761" media="all" rel="Stylesheet" type="text/css" />
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-4453587-1");
pageTracker._trackPageview();
} catch(err) {}
</script>
</head>

<body>
<div id="container">
  <div id="header">
    <h1><span><a href="../../../../index.html">Alice, Bob, and Mallory</a></span></h1>
    <h2>metasyntactics</h2>
  </div>

  <div id="page">
    <div id="content">
      <!--
<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
       xmlns:trackback="http://madskills.com/public/xml/rss/module/trackback/"
       xmlns:dc="http://purl.org/dc/elements/1.1/">
<rdf:Description
    rdf:about=""
    dc:title="Finding primes in parallel"
    dc:identifier="http://alicebobandmallory.com/articles/2010/01/14/prime-factorization-in-parallel"
    dc:description="Justin Etheredge has been blogging about his challenge to find prime numbers with LINQ. He &lt;a href"
    dc:creator="jonelf"
    dc:date="2011-01-21T10:58:29+01:00" />
</rdf:RDF>
-->

<div class="post" onmouseover="if (getCookie('is_admin') == 'yes') { Element.show('admin_article'); }"  onmouseout="Element.hide('admin_article');" >
  <a href="http://alicebobandmallory.com/admin/content/edit/3905" class="admintools" id="admin_article" style="display: none">edit</a>
  <h2>Finding primes in parallel</h2>
  <p class="auth">Posted by Jonas Elfström
  <span class="typo_date" title="Thu, 14 Jan 2010 21:55:00 GMT">Thu, 14 Jan 2010 21:55:00 GMT</span></p>
  <p><a href="http://www.codethinked.com/page/About-Me.aspx">Justin Etheredge</a> has been blogging about his <a href="http://www.codethinked.com/post/2010/01/08/TekPubs-Mastering-LINQ-Challenge.aspx">challenge</a> to find prime numbers with LINQ. He <a href="http://www.codethinked.com/post/2010/01/10/The-TekPub-LINQ-Challenge-Part-2-Faster-Algorithms.aspx">later</a> used <code>AsParallel()</code> (coming in .NET 4) to speed things up and then followed that up with <a href="http://www.codethinked.com/post/2010/01/12/The-TekPub-LINQ-Challenge-And-The-Sieve-Of-Eratosthenes.aspx">a post</a> about using <a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">The Sieve Of Eratosthenes</a>.</p>

<p>As you can see in the comments of those posts I tried to speed the Sieve of Eratosthenes up by using <code>Parallel.For</code> in the inner loop. I also tried AsParallel() in the LINQ expression but it made no difference in either case. At most it got 5% faster. I'm not sure but it could be that because SoE is very memory intense we could have a scaling issue and maybe also memory bandwidth exhaustion. This is mere speculation.</p>

<p>I then searched for other algorithms and found <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">The Sieve of Atkin</a>. It uses less memory than SoE so I thought I'd give it a try.</p>

<p>I set the limit to 20,000,000 and then benchmarked it. It timed in on 2.48s so actually worse than the 2.2s that SoE took. Not good!
Then I added <code>Parallel.For</code> in the loop that did most of the work and  lo and behold, it scaled! I have two cores in my machine (T7200@2.0GHz) and the average runtime went down to 1.26s. That's almost linear and surprisingly good! If you happen have a quad core (or more) and feel like trying it out then please contact me. It would be interesting to see if it scales further. </p>

<table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre><a href="prime-factorization-in-parallel#n1" name="n1">1</a>
<a href="prime-factorization-in-parallel#n2" name="n2">2</a>
<a href="prime-factorization-in-parallel#n3" name="n3">3</a>
<a href="prime-factorization-in-parallel#n4" name="n4">4</a>
<a href="prime-factorization-in-parallel#n5" name="n5">5</a>
<a href="prime-factorization-in-parallel#n6" name="n6">6</a>
<a href="prime-factorization-in-parallel#n7" name="n7">7</a>
<a href="prime-factorization-in-parallel#n8" name="n8">8</a>
<a href="prime-factorization-in-parallel#n9" name="n9">9</a>
<strong><a href="prime-factorization-in-parallel#n10" name="n10">10</a></strong>
<a href="prime-factorization-in-parallel#n11" name="n11">11</a>
<a href="prime-factorization-in-parallel#n12" name="n12">12</a>
<a href="prime-factorization-in-parallel#n13" name="n13">13</a>
<a href="prime-factorization-in-parallel#n14" name="n14">14</a>
<a href="prime-factorization-in-parallel#n15" name="n15">15</a>
<a href="prime-factorization-in-parallel#n16" name="n16">16</a>
<a href="prime-factorization-in-parallel#n17" name="n17">17</a>
<a href="prime-factorization-in-parallel#n18" name="n18">18</a>
<a href="prime-factorization-in-parallel#n19" name="n19">19</a>
<strong><a href="prime-factorization-in-parallel#n20" name="n20">20</a></strong>
<a href="prime-factorization-in-parallel#n21" name="n21">21</a>
<a href="prime-factorization-in-parallel#n22" name="n22">22</a>
<a href="prime-factorization-in-parallel#n23" name="n23">23</a>
<a href="prime-factorization-in-parallel#n24" name="n24">24</a>
<a href="prime-factorization-in-parallel#n25" name="n25">25</a>
<a href="prime-factorization-in-parallel#n26" name="n26">26</a>
<a href="prime-factorization-in-parallel#n27" name="n27">27</a>
<a href="prime-factorization-in-parallel#n28" name="n28">28</a>
<a href="prime-factorization-in-parallel#n29" name="n29">29</a>
<strong><a href="prime-factorization-in-parallel#n30" name="n30">30</a></strong>
<a href="prime-factorization-in-parallel#n31" name="n31">31</a>
<a href="prime-factorization-in-parallel#n32" name="n32">32</a>
<a href="prime-factorization-in-parallel#n33" name="n33">33</a>
<a href="prime-factorization-in-parallel#n34" name="n34">34</a>
<a href="prime-factorization-in-parallel#n35" name="n35">35</a>
<a href="prime-factorization-in-parallel#n36" name="n36">36</a>
<a href="prime-factorization-in-parallel#n37" name="n37">37</a>
<a href="prime-factorization-in-parallel#n38" name="n38">38</a>
<a href="prime-factorization-in-parallel#n39" name="n39">39</a>
<strong><a href="prime-factorization-in-parallel#n40" name="n40">40</a></strong>
<a href="prime-factorization-in-parallel#n41" name="n41">41</a>
<a href="prime-factorization-in-parallel#n42" name="n42">42</a>
<a href="prime-factorization-in-parallel#n43" name="n43">43</a>
<a href="prime-factorization-in-parallel#n44" name="n44">44</a>
<a href="prime-factorization-in-parallel#n45" name="n45">45</a>
<a href="prime-factorization-in-parallel#n46" name="n46">46</a>
</pre></td>
  <td class="code"><pre><span style="color:#088;font-weight:bold">static</span> List&lt;<span style="color:#0a5;font-weight:bold">int</span>&gt; FindPrimesBySieveOfAtkins(<span style="color:#0a5;font-weight:bold">int</span> max)
{
   <span style="color:#777">//  var isPrime = new BitArray((int)max+1, false); </span>
   <span style="color:#777">//  Can't use BitArray because of threading issues.</span>

    var isPrime = new <span style="color:#0a5;font-weight:bold">bool</span>[max + <span style="color:#00D">1</span>];
    var sqrt = (<span style="color:#0a5;font-weight:bold">int</span>)Math.Sqrt(max);

    Parallel.For(<span style="color:#00D">1</span>, sqrt, x =&gt;
    {
        var xx = x * x;
        <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a5;font-weight:bold">int</span> y = <span style="color:#00D">1</span>; y &lt;= sqrt; y++)
        {
            var yy = y * y;
            var n = <span style="color:#00D">4</span> * xx + yy;
            <span style="color:#080;font-weight:bold">if</span> (n &lt;= max &amp;&amp; (n % <span style="color:#00D">12</span> == <span style="color:#00D">1</span> || n % <span style="color:#00D">12</span> == <span style="color:#00D">5</span>))
                isPrime[n] ^= <span style="color:#069">true</span>;

            n = <span style="color:#00D">3</span> * xx + yy;
            <span style="color:#080;font-weight:bold">if</span> (n &lt;= max &amp;&amp; n % <span style="color:#00D">12</span> == <span style="color:#00D">7</span>)
                isPrime[n] ^= <span style="color:#069">true</span>;

            n = <span style="color:#00D">3</span> * xx - yy;
            <span style="color:#080;font-weight:bold">if</span> (x &gt; y &amp;&amp; n &lt;= max &amp;&amp; n % <span style="color:#00D">12</span> == <span style="color:#00D">11</span>)
                isPrime[n] ^= <span style="color:#069">true</span>;
        }
    });

    var primes = new List&lt;<span style="color:#0a5;font-weight:bold">int</span>&gt;() { <span style="color:#00D">2</span>, <span style="color:#00D">3</span> };
    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a5;font-weight:bold">int</span> n = <span style="color:#00D">5</span>; n &lt;= sqrt; n++)
    {
        <span style="color:#080;font-weight:bold">if</span> (isPrime[n])
        {
            primes.Add(n);
            <span style="color:#0a5;font-weight:bold">int</span> nn = n * n;
            <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a5;font-weight:bold">int</span> k = nn; k &lt;= max; k += nn)
                isPrime[k] = <span style="color:#069">false</span>;
        }
    }

    <span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a5;font-weight:bold">int</span> n = sqrt + <span style="color:#00D">1</span>; n &lt;= max; n++)
        <span style="color:#080;font-weight:bold">if</span> (isPrime[n])
            primes.Add(n);

    <span style="color:#080;font-weight:bold">return</span> primes;
}</pre></td>
</tr></table>

<p>This code needs C# 4.0 to compile.
<br><br>
<font style="color:red;font-weight:bold">Edit 2010-12-14</font></p>

<p>Dommer <a href="http://stackoverflow.com/questions/1569127/c-implementation-of-the-sieve-of-atkin/2070579#2070579">found out</a> that the BitArray implementation had some serious threading issues.
I had my worries about the non thread safe characteristics of BitArray but I thought that the isPrime[n] ^= true; was an atomic operation and that it didn't matter in what order bit bits was flipped would make it possible to use anyway. Not so. Changed it to a boolean array and that seems to rock the boat but of course at a much higher memory cost.
<br><br>
<font style="color:red;font-weight:bold">Edit 2010-01-20</font></p>

<p>Indications are that this does in fact not scale very good on a quad core. It's even worse, it seems it scales good on my old T7200 but not on a dual core E6320. I don't know why but of course the shared state of the <strong>isPrime</strong> <code>BitArray</code> is a huge problem and maybe it could be that differences in CPU architecture (FSB speed, caches and so on) in the E6320 is an explanation. Average execution time on the E6320 was 1290ms in a single thread and 1064ms in two.</p>

<p>If you want to try this in an older version of C# than 4.0 then check out <a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">this post</a>.</p>

<p>A reader asked how I timed the executions. Here's how.</p>

<table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre><a href="prime-factorization-in-parallel#n1" name="n1">1</a>
<a href="prime-factorization-in-parallel#n2" name="n2">2</a>
<a href="prime-factorization-in-parallel#n3" name="n3">3</a>
<a href="prime-factorization-in-parallel#n4" name="n4">4</a>
<a href="prime-factorization-in-parallel#n5" name="n5">5</a>
<a href="prime-factorization-in-parallel#n6" name="n6">6</a>
<a href="prime-factorization-in-parallel#n7" name="n7">7</a>
<a href="prime-factorization-in-parallel#n8" name="n8">8</a>
<a href="prime-factorization-in-parallel#n9" name="n9">9</a>
<strong><a href="prime-factorization-in-parallel#n10" name="n10">10</a></strong>
<a href="prime-factorization-in-parallel#n11" name="n11">11</a>
<a href="prime-factorization-in-parallel#n12" name="n12">12</a>
<a href="prime-factorization-in-parallel#n13" name="n13">13</a>
</pre></td>
  <td class="code"><pre>var steps = new List&lt;<span style="color:#0a5;font-weight:bold">long</span>&gt;();
var watch = new Stopwatch();

<span style="color:#080;font-weight:bold">for</span> (<span style="color:#0a5;font-weight:bold">int</span> i = <span style="color:#00D">0</span>; i &lt; <span style="color:#00D">10</span>; i++) 
{
    watch.Reset();
    watch.Start();
    var primes = FindPrimesBySieveOfAtkins(<span style="color:#00D">20000000</span>);
    watch.Stop();
    Console.WriteLine(watch.ElapsedMilliseconds.ToString());
    steps.Add(watch.ElapsedMilliseconds);
}
Console.WriteLine(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Average: </span><span style="color:#710">&quot;</span></span> + steps.Average().ToString());</pre></td>
</tr></table>

<p><br><br>
<font style="color:red;font-weight:bold">Edit 2010-10-24</font>
<br><br>
Tom's code from the comment below</p>

<table class="CodeRay"><tr>
  <td class="line-numbers" title="double click to toggle" ondblclick="with (this.firstChild.style) { display = (display == '') ? 'none' : '' }"><pre><a href="prime-factorization-in-parallel#n1" name="n1">1</a>
<a href="prime-factorization-in-parallel#n2" name="n2">2</a>
<a href="prime-factorization-in-parallel#n3" name="n3">3</a>
<a href="prime-factorization-in-parallel#n4" name="n4">4</a>
<a href="prime-factorization-in-parallel#n5" name="n5">5</a>
<a href="prime-factorization-in-parallel#n6" name="n6">6</a>
<a href="prime-factorization-in-parallel#n7" name="n7">7</a>
<a href="prime-factorization-in-parallel#n8" name="n8">8</a>
<a href="prime-factorization-in-parallel#n9" name="n9">9</a>
<strong><a href="prime-factorization-in-parallel#n10" name="n10">10</a></strong>
<a href="prime-factorization-in-parallel#n11" name="n11">11</a>
<a href="prime-factorization-in-parallel#n12" name="n12">12</a>
<a href="prime-factorization-in-parallel#n13" name="n13">13</a>
<a href="prime-factorization-in-parallel#n14" name="n14">14</a>
<a href="prime-factorization-in-parallel#n15" name="n15">15</a>
<a href="prime-factorization-in-parallel#n16" name="n16">16</a>
<a href="prime-factorization-in-parallel#n17" name="n17">17</a>
<a href="prime-factorization-in-parallel#n18" name="n18">18</a>
<a href="prime-factorization-in-parallel#n19" name="n19">19</a>
<strong><a href="prime-factorization-in-parallel#n20" name="n20">20</a></strong>
<a href="prime-factorization-in-parallel#n21" name="n21">21</a>
<a href="prime-factorization-in-parallel#n22" name="n22">22</a>
<a href="prime-factorization-in-parallel#n23" name="n23">23</a>
<a href="prime-factorization-in-parallel#n24" name="n24">24</a>
<a href="prime-factorization-in-parallel#n25" name="n25">25</a>
<a href="prime-factorization-in-parallel#n26" name="n26">26</a>
<a href="prime-factorization-in-parallel#n27" name="n27">27</a>
<a href="prime-factorization-in-parallel#n28" name="n28">28</a>
<a href="prime-factorization-in-parallel#n29" name="n29">29</a>
<strong><a href="prime-factorization-in-parallel#n30" name="n30">30</a></strong>
<a href="prime-factorization-in-parallel#n31" name="n31">31</a>
<a href="prime-factorization-in-parallel#n32" name="n32">32</a>
<a href="prime-factorization-in-parallel#n33" name="n33">33</a>
<a href="prime-factorization-in-parallel#n34" name="n34">34</a>
<a href="prime-factorization-in-parallel#n35" name="n35">35</a>
<a href="prime-factorization-in-parallel#n36" name="n36">36</a>
<a href="prime-factorization-in-parallel#n37" name="n37">37</a>
<a href="prime-factorization-in-parallel#n38" name="n38">38</a>
<a href="prime-factorization-in-parallel#n39" name="n39">39</a>
<strong><a href="prime-factorization-in-parallel#n40" name="n40">40</a></strong>
<a href="prime-factorization-in-parallel#n41" name="n41">41</a>
<a href="prime-factorization-in-parallel#n42" name="n42">42</a>
<a href="prime-factorization-in-parallel#n43" name="n43">43</a>
<a href="prime-factorization-in-parallel#n44" name="n44">44</a>
<a href="prime-factorization-in-parallel#n45" name="n45">45</a>
<a href="prime-factorization-in-parallel#n46" name="n46">46</a>
<a href="prime-factorization-in-parallel#n47" name="n47">47</a>
<a href="prime-factorization-in-parallel#n48" name="n48">48</a>
<a href="prime-factorization-in-parallel#n49" name="n49">49</a>
<strong><a href="prime-factorization-in-parallel#n50" name="n50">50</a></strong>
<a href="prime-factorization-in-parallel#n51" name="n51">51</a>
<a href="prime-factorization-in-parallel#n52" name="n52">52</a>
<a href="prime-factorization-in-parallel#n53" name="n53">53</a>
<a href="prime-factorization-in-parallel#n54" name="n54">54</a>
<a href="prime-factorization-in-parallel#n55" name="n55">55</a>
<a href="prime-factorization-in-parallel#n56" name="n56">56</a>
<a href="prime-factorization-in-parallel#n57" name="n57">57</a>
<a href="prime-factorization-in-parallel#n58" name="n58">58</a>
<a href="prime-factorization-in-parallel#n59" name="n59">59</a>
<strong><a href="prime-factorization-in-parallel#n60" name="n60">60</a></strong>
<a href="prime-factorization-in-parallel#n61" name="n61">61</a>
<a href="prime-factorization-in-parallel#n62" name="n62">62</a>
<a href="prime-factorization-in-parallel#n63" name="n63">63</a>
<a href="prime-factorization-in-parallel#n64" name="n64">64</a>
<a href="prime-factorization-in-parallel#n65" name="n65">65</a>
<a href="prime-factorization-in-parallel#n66" name="n66">66</a>
<a href="prime-factorization-in-parallel#n67" name="n67">67</a>
<a href="prime-factorization-in-parallel#n68" name="n68">68</a>
<a href="prime-factorization-in-parallel#n69" name="n69">69</a>
<strong><a href="prime-factorization-in-parallel#n70" name="n70">70</a></strong>
<a href="prime-factorization-in-parallel#n71" name="n71">71</a>
<a href="prime-factorization-in-parallel#n72" name="n72">72</a>
<a href="prime-factorization-in-parallel#n73" name="n73">73</a>
<a href="prime-factorization-in-parallel#n74" name="n74">74</a>
<a href="prime-factorization-in-parallel#n75" name="n75">75</a>
<a href="prime-factorization-in-parallel#n76" name="n76">76</a>
<a href="prime-factorization-in-parallel#n77" name="n77">77</a>
<a href="prime-factorization-in-parallel#n78" name="n78">78</a>
<a href="prime-factorization-in-parallel#n79" name="n79">79</a>
<strong><a href="prime-factorization-in-parallel#n80" name="n80">80</a></strong>
<a href="prime-factorization-in-parallel#n81" name="n81">81</a>
<a href="prime-factorization-in-parallel#n82" name="n82">82</a>
<a href="prime-factorization-in-parallel#n83" name="n83">83</a>
<a href="prime-factorization-in-parallel#n84" name="n84">84</a>
</pre></td>
  <td class="code"><pre>using System; 
using System.Collections.Generic; 
using System.Linq; 
using System.Numerics; 
using System.Text; 
using System.Threading.Tasks;

namespace Calculate_Primes 
{ 
    class Program 
    { 
        private <span style="color:#088;font-weight:bold">const</span> <span style="color:#0a5;font-weight:bold">int</span> _NUMBER_OF_DIGITS = <span style="color:#00D">100</span>;

        <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">void</span> Main(string[] args)
        {
            BigInteger floor = BigInteger.Parse(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">1</span><span style="color:#710">&quot;</span></span> + string.Empty.PadLeft(_NUMBER_OF_DIGITS - <span style="color:#00D">1</span>, <span style="color:#D20">'0'</span>));
            BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, <span style="color:#D20">'9'</span>));

            Console.WindowWidth = <span style="color:#00D">150</span>;

            <span style="color:#777">//var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);</span>

            Console.Clear();
            _calculatePrimes(floor, ceiling, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">C:</span><span style="color:#b0b">\\</span><span style="color:#D20">100 digit primes.txt</span><span style="color:#710">&quot;</span></span>);

            Console.Clear();
            _calculatePrimes(floor, ceiling, <span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">C:</span><span style="color:#b0b">\\</span><span style="color:#D20">300 digit primes.txt</span><span style="color:#710">&quot;</span></span>);
        }

        <span style="color:#088;font-weight:bold">static</span> IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
        {
            <span style="color:#080;font-weight:bold">for</span> (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
                yield <span style="color:#080;font-weight:bold">return</span> i;
        }

        <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">void</span> ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
        {
            Parallel.ForEach(Range(fromInclusive, toInclusive), body);
        } 

        <span style="color:#088;font-weight:bold">static</span> <span style="color:#088;font-weight:bold">void</span> _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
        {
            using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

            using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
            {
                ParallelFor(floor, ceiling, i =&gt;
                    {
                        <span style="color:#080;font-weight:bold">if</span> (_isPrime(i))
                        {
                            lock (sw)
                            {
                                sw.Write(i.ToString() + System.Environment.NewLine);
                                sw.Flush();
                            }
                        }
                    });
            }
        }

        <span style="color:#088;font-weight:bold">static</span> <span style="color:#0a5;font-weight:bold">bool</span> _isPrime(BigInteger number)
        {
            <span style="color:#0a5;font-weight:bold">bool</span> returnValue = <span style="color:#069">true</span>;

            Console.WriteLine(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">Checking {0} for primality.</span><span style="color:#710">&quot;</span></span>, number.ToString());

            <span style="color:#080;font-weight:bold">if</span> ((number &lt; <span style="color:#00D">2</span>) || (number &gt; <span style="color:#00D">2</span> &amp;&amp; number.IsEven) || (number &gt; <span style="color:#00D">2</span> &amp;&amp; number.IsPowerOfTwo))
                returnValue = <span style="color:#069">false</span>;
            <span style="color:#080;font-weight:bold">else</span>
                <span style="color:#080;font-weight:bold">for</span> (BigInteger i = <span style="color:#00D">2</span>; i * i &lt;= number; i++)
                {
                    <span style="color:#080;font-weight:bold">if</span> (number % i == <span style="color:#00D">0</span>)
                        returnValue = <span style="color:#069">false</span>;
                }

            <span style="color:#080;font-weight:bold">if</span>(returnValue)
                Console.WriteLine(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">         {0} IS prime.</span><span style="color:#710">&quot;</span></span>, number.ToString());
            <span style="color:#080;font-weight:bold">else</span>
                Console.WriteLine(<span style="background-color:hsla(0,100%,50%,0.05)"><span style="color:#710">&quot;</span><span style="color:#D20">         {0} IS NOT prime.</span><span style="color:#710">&quot;</span></span>, number.ToString());

            <span style="color:#080;font-weight:bold">return</span> returnValue;
        }
    }
}</pre></td>
</tr></table>
</div>
<p class="meta">
  Posted in <a href="http://alicebobandmallory.com/articles/category/c" rel="noindex, follow, tag">C#</a>, <a href="http://alicebobandmallory.com/articles/category/math" rel="noindex, follow, tag">Math</a>&nbsp;<strong>|</strong>&nbsp;<a href="prime-factorization-in-parallel#comments">19 comments</a>
</p>

  <a name="comments"></a><h4 class="blueblk">Comments</h4>
    <p class="postmetadata alt">
      <small><a href="prime-factorization-in-parallel#respond">Comments closed</a></small>
    </p>
  <ol class="comment-list" id="commentList">
  
    <ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>
<ol id="comments" class="comments">
  	<li class="comment" id="comment-3908">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T11:03:18+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 10:03:18 GMT">Fri, 15 Jan 2010 10:03:18 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Are BitArrays thread-safe, or how does that work?</p>

<p>Is it possible to write a version of this without the Parrallel.For method? Well, I suppose it is possible of course, but would it be a big mess? :p</p>
	  </div>
	</li>
		<li class="comment" id="comment-3909">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T13:33:16+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 12:33:16 GMT">Fri, 15 Jan 2010 12:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Replace the Parallel.For with
for (int x = 1; x &lt;= sqrt; x++)
and remove ); from row 24 and you should be good to go.</p>

<p>If I understand 
<a href="http://bit.ly/8lZagW">http://bit.ly/8lZagW</a> correctly the isPrime[n] = !isPrime[n]; is an atomic operation but I have to investigate the matter of thread safety further. Thanks!</p>
	  </div>
	</li>
		<li class="comment" id="comment-3911">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:47:57+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:47:57 GMT">Fri, 15 Jan 2010 14:47:57 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>But that would remove the parallelism :p I was wondering if it could be done in a nice way without using Parallel.For, but still have the parallelism. (So do whatever Parallel.For does yourself)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3912">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-15T15:50:13+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 14:50:13 GMT">Fri, 15 Jan 2010 14:50:13 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>From that link you posted: &#8220;Aside from the library functions designed for that purpose, there is no guarantee of atomic read-modify-write, such as in the case of increment or decrement.&#8221; &#8211; Wouldn&#8217;t that mean that it is not thread-safe? or?</p>
	  </div>
	</li>
		<li class="comment" id="comment-3913">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T16:23:15+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 15:23:15 GMT">Fri, 15 Jan 2010 15:23:15 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>That&#8217;s for &#8220;long, ulong, double, and decimal&#8221;.
Read/write of booleans is atomic. I&#8217;m just not sure that isPrime[n] = !isPrime[n]; is the same as 
Boolean test = false;
test = !test;
which would be atomic.</p>
	  </div>
	</li>
		<li class="comment" id="comment-3914">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-15T17:24:41+01:00"><span class="typo_date" title="Fri, 15 Jan 2010 16:24:41 GMT">Fri, 15 Jan 2010 16:24:41 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>If Holterman is correct then my usage is thread safe: <a href="http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686">http://stackoverflow.com/questions/1213997/is-there-a-generic-type-safe-bitarray-in-net/1214686#1214686</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3919">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-16T16:11:21+01:00"><span class="typo_date" title="Sat, 16 Jan 2010 15:11:21 GMT">Sat, 16 Jan 2010 15:11:21 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><i>&#8220;I was wondering if it could be done in a nice way without using Parallel.&#8221;</i></p>

<p>Check out:  <a href="http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx">http://www.codeproject.com/KB/dotnet/PoorMansParallelForEach.aspx</a></p>
	  </div>
	</li>
		<li class="comment" id="comment-3934">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=84217a94f2ddb2f0f9c74fab839e28a5&amp;size=60" /></div>
	    <cite><a href="http://www.geekality.net">Svish</a></cite>
		<abbr title="2010-01-19T18:33:16+01:00"><span class="typo_date" title="Tue, 19 Jan 2010 17:33:16 GMT">Tue, 19 Jan 2010 17:33:16 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>So should maybe use the Set method instead then? Or doesn&#8217;t make much difference perhaps&#8230;</p>

<p>Thanks for the link. Will check it out :)</p>
	  </div>
	</li>
		<li class="comment" id="comment-3939">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-01-20T09:11:22+01:00"><span class="typo_date" title="Wed, 20 Jan 2010 08:11:22 GMT">Wed, 20 Jan 2010 08:11:22 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p><a href="http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html">http://coding-time.blogspot.com/2008/03/implement-your-own-parallelfor-in-c.html</a> - makes it possible to run FindPrimesBySieveOfAtkins unchanged in C# 2.0-3.5.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4397">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:35:54+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:35:54 GMT">Fri, 22 Oct 2010 16:35:54 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>These lines:
isPrime[n] = !isPrime[n];</p>

<p>Should be replaced with
isPrime[n] ^= true;</p>

<p>No more atomicity.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4398">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Tom</cite>
		<abbr title="2010-10-22T18:59:47+02:00"><span class="typo_date" title="Fri, 22 Oct 2010 16:59:47 GMT">Fri, 22 Oct 2010 16:59:47 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>Here&#8217;s a little something I came up with&#8211;except for the commented out LINQ query&#8211;using Stephen Toub&#8217;s comments on Scott Hansellman&#8217;s blog:</p>

<p>using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Threading.Tasks;
namespace Calculate_Primes
{
    class Program
    {
        private const int <em>NUMBER</em>OF_DIGITS = 100;</p>

<pre><code>    static void Main(string[] args)
    {
        BigInteger floor = BigInteger.Parse("1" + string.Empty.PadLeft(_NUMBER_OF_DIGITS - 1, '0'));
        BigInteger ceiling = BigInteger.Parse(string.Empty.PadLeft(_NUMBER_OF_DIGITS, '9'));

        Console.WindowWidth = 150;

        //var primes = Enumerable.Range(floor, ceiling).Where(n =&gt; Enumerable.Range(1, n).Where(m =&gt; (n / m) * m == n).Count() == 2);

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\100 digit primes.txt");

        Console.Clear();
        _calculatePrimes(floor, ceiling, "C:\300 digit primes.txt");
    }

    static IEnumerable&lt;BigInteger&gt; Range(BigInteger fromInclusive, BigInteger toInclusive)
    {
        for (BigInteger i = fromInclusive; i &lt;= toInclusive; i++)
            yield return i;
    }

    static void ParallelFor(BigInteger fromInclusive, BigInteger toInclusive, Action&lt;BigInteger&gt; body)
    {
        Parallel.ForEach(Range(fromInclusive, toInclusive), body);
    } 

    static void _calculatePrimes(BigInteger floor, BigInteger ceiling, string resultsFileFilepath)
    {
        using (System.IO.FileStream fs = new System.IO.FileStream(resultsFileFilepath, System.IO.FileMode.Create)) { }

        using (System.IO.StreamWriter sw = new System.IO.StreamWriter(resultsFileFilepath))
        {
            ParallelFor(floor, ceiling, i =&gt;
                {
                    if (_isPrime(i))
                    {
                        lock (sw)
                        {
                            sw.Write(i.ToString() + System.Environment.NewLine);
                            sw.Flush();
                        }
                    }
                });
        }
    }

    static bool _isPrime(BigInteger number)
    {
        bool returnValue = true;

        Console.WriteLine("Checking {0} for primality.", number.ToString());

        if ((number &lt; 2) || (number &gt; 2 &amp;&amp; number.IsEven) || (number &gt; 2 &amp;&amp; number.IsPowerOfTwo))
            returnValue = false;
        else
            for (BigInteger i = 2; i * i &lt;= number; i++)
            {
                if (number % i == 0)
                    returnValue = false;
            }

        if(returnValue)
            Console.WriteLine("         {0} IS prime.", number.ToString());
        else
            Console.WriteLine("         {0} IS NOT prime.", number.ToString());

        return returnValue;
    }
}
</code></pre>

<p>}</p>
	  </div>
	</li>
		<li class="comment" id="comment-4402">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:10:50+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:10:50 GMT">Sat, 23 Oct 2010 22:10:50 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom</p>

<blockquote>
    <p>isPrime[n] ^= true</p>
</blockquote>

<p>An XOR toggle, nice! I haven&#8217;t checked it but I would guess that both that and mine compile to something similar.</p>

<blockquote>
    <p>No more atomicity.</p>
</blockquote>

<p>Now you lost me. I believe it is and that that&#8217;s a good thing.</p>
	  </div>
	</li>
		<li class="comment" id="comment-4403">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-10-24T00:22:29+02:00"><span class="typo_date" title="Sat, 23 Oct 2010 22:22:29 GMT">Sat, 23 Oct 2010 22:22:29 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Tom Thanks for the code and sorry for the not so fancy commenting function on my blog. </p>

<p>I think that you are right in that brute force prime search scales over multiple CPUs. It could be a problem that it&#8217;s so terrible slow in comparance to The Sieve Of Eratosthene and The Sieve of Atkin, I just don&#8217;t know. Guess I have to read up on how those gigantic primes that have been found was found.</p>
	  </div>
	</li>
		<li class="comment" id="comment-5197">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=8a02f944cd1dcd75aef79b187558d306&amp;size=60" /></div>
	    <cite><a href="http://bigintegers.blogspot.com/2010/12/primes-sieve-of-eratosthenes.html">Peter</a></cite>
		<abbr title="2010-12-21T16:47:04+01:00"><span class="typo_date" title="Tue, 21 Dec 2010 15:47:04 GMT">Tue, 21 Dec 2010 15:47:04 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>This implementation of the sieve of Eatosthenes should take about 500 ms on your PC finding primes upto 20*10^6</p>

<p>Regards,</p>

<p>Peter</p>
	  </div>
	</li>
		<li class="comment" id="comment-5199">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite>Jonas Elfström</cite>
		<abbr title="2010-12-22T11:20:23+01:00"><span class="typo_date" title="Wed, 22 Dec 2010 10:20:23 GMT">Wed, 22 Dec 2010 10:20:23 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@Peter Thanks! Even though Sieve of Atkin in theory should be faster than Sieve of Eratosthenes your implementation of the latter is much faster than mine of the former. I&#8217;m not surprised because I just did a naive translation from the <a href="http://en.wikipedia.org/wiki/Sieve_of_Atkin">pseudo code on Wikipedia</a> to C#.</p>

<p>Also my implementation can&#8217;t handle searching for primes up to 1000000000. It seems to be the line <code>int n = 4 * xx + yy;</code> that is the problem. <code>4*xx+yy</code> does not fit in a <code>Int32</code> for max=1000000000.</p>

<pre>
Peter's impl. of The Sieve Of Eratosthenes
n: 10000  primes: 1229 in 0 ms
n: 100000  primes: 9592 in 2 ms
n: 1000000  primes: 78498 in 20 ms
n: 10000000  primes: 664579 in 213 ms
n: 100000000  primes: 5761455 in 2744 ms
n: 1000000000  primes: 50847534 in 33338 ms

My impl. of The Sieve Of Atkin
n: 10000  primes: 1229 in 3 ms
n: 100000  primes: 9592 in 6 ms
n: 1000000  primes: 78498 in 64 ms
n: 10000000  primes: 664579 in 584 ms
n: 100000000  primes: 5761455 in 7612 ms
</pre>
	  </div>
	</li>
		<li class="comment" id="comment-5234">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=3961ab338b50525f6ab04d0321a5d1b8&amp;size=60" /></div>
	    <cite><a href="http://djproduct.blogspot.com/">Dave Jellison</a></cite>
		<abbr title="2011-02-17T01:01:58+01:00"><span class="typo_date" title="Thu, 17 Feb 2011 00:01:58 GMT">Thu, 17 Feb 2011 00:01:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>FWIW: 20M took 387 ms on my 6 core using the algo in this post. Rockin! Thanks for the C# implementation.</p>
	  </div>
	</li>
		<li class="comment" id="comment-6723">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Freeman</cite>
		<abbr title="2011-11-16T15:00:58+01:00"><span class="typo_date" title="Wed, 16 Nov 2011 14:00:58 GMT">Wed, 16 Nov 2011 14:00:58 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>just wanted to say you can use watch.Restart() instead of     watch.Reset();
    watch.Start();</p>
	  </div>
	</li>
		<li class="comment" id="comment-7547">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=d41d8cd98f00b204e9800998ecf8427e&amp;size=60" /></div>
	    <cite>Aaron M</cite>
		<abbr title="2012-03-10T21:18:45+01:00"><span class="typo_date" title="Sat, 10 Mar 2012 20:18:45 GMT">Sat, 10 Mar 2012 20:18:45 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>You can fix the original posting without using boolean arrays, but you would need to create a bit array for each thread and do each one separately, then after all the threads are finished, simply XOR them all together, this give the best of both worlds.</p>
	  </div>
	</li>
		<li class="comment" id="comment-7589">
	  <div class="author">
	    <div><img alt="Avatar" class="gravatar" src="http://www.gravatar.com/avatar.php?gravatar_id=9e36aeb20f1b4a763043d3ce4942b454&amp;size=60" /></div>
	    <cite><a href="../../../../index.html">Jonas</a></cite>
		<abbr title="2012-03-14T01:20:19+01:00"><span class="typo_date" title="Wed, 14 Mar 2012 00:20:19 GMT">Wed, 14 Mar 2012 00:20:19 GMT</span></abbr>
	  </div>
	  <div class="content">
	    <p>@AronM That sounds ingeniously simple! I will have to try that out. Still worried about the XOR. Why wouldn&#8217;t it be affected by all other threads?</p>
	  </div>
	</li>
	</ol>

  
  </ol>


<p class="postmetadata alt">
  <small>
  <a href="../../../../xml/rss20/article/3905/feed.xml" title="RSS Feed">RSS feed for this post</a>
  </small>
</p>


<p>Comments are closed</p>
<!--
  <p>Comments are disabled</p>
-->

      <script type="text/javascript">
//<![CDATA[
show_dates_as_local_time()
//]]>
</script>
    </div>

    <div id="sidebar">
      <!-- search -->
      <div id="search" class="search">
<!--	<form action="/articles/search" id="sform" method="get">
	  <p><input type="text" id="q" name="q" value="" /></p>
	</form>
	
	<div id="loading" class="loading" style="display:none;">Searching...</div>
	<div id="results" class="results"></div>
  <script type="text/javascript">
//<![CDATA[
new Form.Element.Observer('q', 1, function(element, value) {new Ajax.Updater('results', '/live/search', {asynchronous:true, evalScripts:true, onComplete:function(request){Element.hide('loading')}, onLoading:function(request){Element.show('loading')}, parameters:'q=' + escape($F('q'))})})
//]]>
</script>
-->
</div>


      <!-- sidebar components -->
      
      
<div class="sidebar-node">
  <h3></h3>
<a href="http://stackoverflow.com/users/44620/jonas-elfstrom">
<img src="http://stackoverflow.com/users/flair/44620.png" width="208" height="58" alt="Stack Overflow profile for Jonas Elfström" title="Stack Overflow profile for Jonas Elfström">
</a>
<ul>
<li><nobr><a href="../../../../pages/AboutMe">About me</a>/<a href="../../../../pages/OmMig">Om mig</a></nobr></li>
</ul>
<a href="https://gist.github.com/jonelf">Public Gists</a><br><a href="http://jonelf.posterous.com/">Posterous</a><br><br>
<b>Recommended reading</b><br/><a href="http://www.amazon.com/gp/product/0385495323?ie=UTF8&tag=alibobandmal-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0385495323">The Code Book</a><img src="http://www.assoc-amazon.com/e/ir?t=alibobandmal-20&l=as2&o=1&a=0385495323" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
<br/>
<a href="http://www.amazon.com/gp/product/0385493622?ie=UTF8&tag=alibobandmal-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0385493622">Fermat's Enigma</a><img src="http://www.assoc-amazon.com/e/ir?t=alibobandmal-20&l=as2&o=1&a=0385493622" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br/>
<a href="http://www.amazon.com/gp/product/0399156828?ie=UTF8&tag=alibobandmal-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0399156828">Zero History</a><img src="http://www.assoc-amazon.com/e/ir?t=alibobandmal-20&l=as2&o=1&a=0399156828" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" /><br/>
<a href="http://www.amazon.com/gp/product/0470474246?ie=UTF8&tag=alibobandmal-20&linkCode=as2&camp=1789&creative=9325&creativeASIN=0470474246">Cryptography Engineering</a><img src="http://www.assoc-amazon.com/e/ir?t=alibobandmal-20&l=as2&o=1&a=0470474246" width="1" height="1" border="0" alt="" style="border:none !important; margin:0px !important;" />
<br/><br/>

</div>


  


    </div>
    <br style="clear:both;" />
  </div>

  <div id="footer">
    <hr />
    <p><a href="../../../../index.html">Alice, Bob, and Mallory</a></p>
    <ul>
      <li>powered by <a href="http://typosphere.org">typo</a> /
          styled with <a href="http://quotedprintable.com/pages/scribbish">scribbish</a></li>
    </ul>
  </div>
</div>
</body>
</html>
